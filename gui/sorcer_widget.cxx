// generated by Fast Light User Interface Designer (fluid) version 1.0300

#include "sorcer_widget.h"

void SorcerUI::cb_Wave_i(Avtk::Background* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_Wave(Avtk::Background* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_Wave_i(o,v);
}

void SorcerUI::cb_Wave1_i(Avtk::Background* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_Wave1(Avtk::Background* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_Wave1_i(o,v);
}

void SorcerUI::cb_Sub_i(Avtk::Background* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_Sub(Avtk::Background* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_Sub_i(o,v);
}

void SorcerUI::cb_LFO_i(Avtk::Background* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_LFO(Avtk::Background* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_LFO_i(o,v);
}

void SorcerUI::cb_Remove_i(Avtk::Background* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_Remove(Avtk::Background* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_Remove_i(o,v);
}

void SorcerUI::cb_ADSR_i(Avtk::Background* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_ADSR(Avtk::Background* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_ADSR_i(o,v);
}

void SorcerUI::cb_Master_i(Avtk::Background* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_Master(Avtk::Background* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_Master_i(o,v);
}

void SorcerUI::cb_wave1_i(Avtk::Oscillator* o, void*) {
  float x = o->X();
float y = o->Y();
writePort(OSC_1_VOLUME, y);
writePort(WAVETABLE_1_POS, x);
}
void SorcerUI::cb_wave1(Avtk::Oscillator* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_wave1_i(o,v);
}

void SorcerUI::cb_wave2_i(Avtk::Oscillator* o, void*) {
  float x = o->X();
float y = o->Y();
writePort(OSC_2_VOLUME, y);
writePort(WAVETABLE_2_POS, x);
}
void SorcerUI::cb_wave2(Avtk::Oscillator* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_wave2_i(o,v);
}

void SorcerUI::cb_subbass_i(Avtk::Oscillator* o, void*) {
  o->X( 0.5 );
o->modulation( 0 );
float tmp = o->Y();
writePort(OSC_3_VOLUME, tmp );
}
void SorcerUI::cb_subbass(Avtk::Oscillator* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_subbass_i(o,v);
}

void SorcerUI::cb_lfo_i(Avtk::LFO* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_lfo(Avtk::LFO* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_lfo_i(o,v);
}

void SorcerUI::cb_lfoSpeed_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
lfo->modulation( tmp );
writePort( int(LFO_FREQUENCY), tmp );
}
void SorcerUI::cb_lfoSpeed(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_lfoSpeed_i(o,v);
}

void SorcerUI::cb_lfoToW2_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
wave2->modulation( tmp );
writePort( int(LFO_TO_WAVETABLE_2), tmp );
}
void SorcerUI::cb_lfoToW2(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_lfoToW2_i(o,v);
}

void SorcerUI::cb_lfoToW1_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
wave1->modulation( tmp );
writePort( int(LFO_TO_WAVETABLE_1),tmp );
}
void SorcerUI::cb_lfoToW1(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_lfoToW1_i(o,v);
}

void SorcerUI::cb_lfoAmp_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
lfo->value( tmp );
writePort( int(LFO_AMPLITUDE), tmp );
}
void SorcerUI::cb_lfoAmp(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_lfoAmp_i(o,v);
}

void SorcerUI::cb_filter_i(Avtk::Filtergraph* o, void*) {
  float tmp = o->value();
filterCutoff->value( tmp );
writePort( int(FILTER_CUTOFF),tmp );
}
void SorcerUI::cb_filter(Avtk::Filtergraph* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_filter_i(o,v);
}

void SorcerUI::cb_filterCutoff_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
filter->value( tmp );
writePort( int(FILTER_CUTOFF),tmp );
}
void SorcerUI::cb_filterCutoff(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_filterCutoff_i(o,v);
}

void SorcerUI::cb_filterLfoMod_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
filter->modulation( tmp );
writePort( int(LFO_TO_FILTER_RANGE),tmp );
}
void SorcerUI::cb_filterLfoMod(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_filterLfoMod_i(o,v);
}

void SorcerUI::cb_adsr_i(Avtk::ADSR* o, void*) {
  //cutoff = o->value();
//float g = o->getGain();
//gainDial->value( g );
//freq->value( cutoff ); // update dial
//writePort(CUTOFF_FREQ, cutoff);
//writePort(CUTOFF_GAIN, g);
}
void SorcerUI::cb_adsr(Avtk::ADSR* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_adsr_i(o,v);
}

void SorcerUI::cb_sustain_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
adsr->sustain( tmp );
writePort( int(ADSR_SUSTAIN),tmp );
}
void SorcerUI::cb_sustain(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_sustain_i(o,v);
}

void SorcerUI::cb_decay_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
adsr->decay( tmp );
writePort( int(ADSR_DECAY),tmp );
}
void SorcerUI::cb_decay(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_decay_i(o,v);
}

void SorcerUI::cb_attack_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
adsr->attack( tmp );
writePort( int(ADSR_ATTACK),tmp );
}
void SorcerUI::cb_attack(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_attack_i(o,v);
}

void SorcerUI::cb_release_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
adsr->release( tmp );
writePort( int(ADSR_RELEASE),tmp );
}
void SorcerUI::cb_release(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_release_i(o,v);
}

void SorcerUI::cb_volume_i(Avtk::Volume* o, void*) {
  float tmp = o->value(); //pow( , 4 );
writePort( int(VOLUME), tmp );
}
void SorcerUI::cb_volume(Avtk::Volume* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_volume_i(o,v);
}

void SorcerUI::cb_comp_i(Avtk::Compressor* o, void*) {
  float tmp = o->getActive();
writePort( int(COMPRESSOR_ENABLE), tmp );
}
void SorcerUI::cb_comp(Avtk::Compressor* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_comp_i(o,v);
}

void SorcerUI::cb_compThres_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
comp->threshold( tmp );
writePort( int(COMPRESSOR_THRESHOLD),tmp );
}
void SorcerUI::cb_compThres(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_compThres_i(o,v);
}

void SorcerUI::cb_compAttack_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
//comp->attack( tmp );
writePort( int(COMPRESSOR_ATTACK),tmp );
}
void SorcerUI::cb_compAttack(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_compAttack_i(o,v);
}

void SorcerUI::cb_compMakeup_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
comp->makeup( tmp );
writePort( int(COMPRESSOR_MAKEUP),tmp );
}
void SorcerUI::cb_compMakeup(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_compMakeup_i(o,v);
}

void SorcerUI::cb_compRelease_i(Avtk::Dial* o, void*) {
  float tmp = o->value();
//comp->release( tmp );
writePort( int(COMPRESSOR_RELEASE),tmp );
}
void SorcerUI::cb_compRelease(Avtk::Dial* o, void* v) {
  ((SorcerUI*)(o->parent()->user_data()))->cb_compRelease_i(o,v);
}

/**
   if the type of filter changes, this function will highlight the right button
*/
void SorcerUI::update_button(int button) {
}

SorcerUI::SorcerUI() {
  { window = new Fl_Double_Window(515, 450);
    window->color((Fl_Color)48);
    window->user_data((void*)(this));
    { headerImage = new Avtk::Image(0, 0, 515, 36, "header.png");
      headerImage->box(FL_NO_BOX);
      headerImage->color(FL_BACKGROUND_COLOR);
      headerImage->selection_color(FL_BACKGROUND_COLOR);
      headerImage->labeltype(FL_NORMAL_LABEL);
      headerImage->labelfont(0);
      headerImage->labelsize(14);
      headerImage->labelcolor((Fl_Color)20);
      headerImage->align(Fl_Align(FL_ALIGN_CENTER));
      headerImage->when(FL_WHEN_RELEASE_ALWAYS);
      headerImage->setPixbuf(header.pixel_data,4);
    } // Avtk::Image* headerImage
    { Avtk::Background* o = new Avtk::Background(10, 40, 158, 126, "Wave 1");
      o->box(FL_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)20);
      o->callback((Fl_Callback*)cb_Wave);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
    } // Avtk::Background* o
    { Avtk::Background* o = new Avtk::Background(10, 174, 158, 126, "Wave 2");
      o->box(FL_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)20);
      o->callback((Fl_Callback*)cb_Wave1);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
    } // Avtk::Background* o
    { Avtk::Background* o = new Avtk::Background(10, 311, 158, 126, "Sub-Bass");
      o->box(FL_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)20);
      o->callback((Fl_Callback*)cb_Sub);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
    } // Avtk::Background* o
    { Avtk::Background* o = new Avtk::Background(179, 40, 158, 194, "LFO");
      o->box(FL_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)20);
      o->callback((Fl_Callback*)cb_LFO);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
    } // Avtk::Background* o
    { Avtk::Background* o = new Avtk::Background(179, 244, 158, 194, "Remove");
      o->box(FL_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)20);
      o->callback((Fl_Callback*)cb_Remove);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
    } // Avtk::Background* o
    { Avtk::Background* o = new Avtk::Background(348, 40, 158, 194, "ADSR");
      o->box(FL_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)20);
      o->callback((Fl_Callback*)cb_ADSR);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
    } // Avtk::Background* o
    { Avtk::Background* o = new Avtk::Background(348, 244, 158, 194, "Master");
      o->box(FL_UP_BOX);
      o->color(FL_BACKGROUND_COLOR);
      o->selection_color(FL_BACKGROUND_COLOR);
      o->labeltype(FL_NO_LABEL);
      o->labelfont(0);
      o->labelsize(14);
      o->labelcolor((Fl_Color)20);
      o->callback((Fl_Callback*)cb_Master);
      o->align(Fl_Align(FL_ALIGN_CENTER));
      o->when(FL_WHEN_RELEASE);
    } // Avtk::Background* o
    { wave1 = new Avtk::Oscillator(15, 64, 148, 98, "Wave 1");
      wave1->box(FL_UP_BOX);
      wave1->color((Fl_Color)179);
      wave1->selection_color(FL_INACTIVE_COLOR);
      wave1->labeltype(FL_NO_LABEL);
      wave1->labelfont(0);
      wave1->labelsize(14);
      wave1->labelcolor(FL_FOREGROUND_COLOR);
      wave1->callback((Fl_Callback*)cb_wave1);
      wave1->align(Fl_Align(FL_ALIGN_BOTTOM));
      wave1->when(FL_WHEN_CHANGED);
    } // Avtk::Oscillator* wave1
    { wave2 = new Avtk::Oscillator(15, 198, 148, 98, "Wave 2");
      wave2->box(FL_UP_BOX);
      wave2->color((Fl_Color)179);
      wave2->selection_color(FL_INACTIVE_COLOR);
      wave2->labeltype(FL_NO_LABEL);
      wave2->labelfont(0);
      wave2->labelsize(14);
      wave2->labelcolor(FL_FOREGROUND_COLOR);
      wave2->callback((Fl_Callback*)cb_wave2);
      wave2->align(Fl_Align(FL_ALIGN_BOTTOM));
      wave2->when(FL_WHEN_CHANGED);
    } // Avtk::Oscillator* wave2
    { subbass = new Avtk::Oscillator(15, 335, 148, 98, "Sub-Bass");
      subbass->box(FL_UP_BOX);
      subbass->color((Fl_Color)179);
      subbass->selection_color(FL_INACTIVE_COLOR);
      subbass->labeltype(FL_NO_LABEL);
      subbass->labelfont(0);
      subbass->labelsize(14);
      subbass->labelcolor(FL_FOREGROUND_COLOR);
      subbass->callback((Fl_Callback*)cb_subbass);
      subbass->align(Fl_Align(FL_ALIGN_BOTTOM));
      subbass->when(FL_WHEN_CHANGED);
    } // Avtk::Oscillator* subbass
    { lfo = new Avtk::LFO(184, 64, 148, 90, "LFO");
      lfo->box(FL_UP_BOX);
      lfo->color((Fl_Color)179);
      lfo->selection_color(FL_INACTIVE_COLOR);
      lfo->labeltype(FL_NO_LABEL);
      lfo->labelfont(0);
      lfo->labelsize(14);
      lfo->labelcolor(FL_FOREGROUND_COLOR);
      lfo->callback((Fl_Callback*)cb_lfo);
      lfo->align(Fl_Align(FL_ALIGN_BOTTOM));
      lfo->when(FL_WHEN_CHANGED);
    } // Avtk::LFO* lfo
    { lfoBox = new Fl_Box(182, 157, 152, 75);
      lfoBox->box(FL_DOWN_BOX);
      lfoBox->labeltype(FL_NO_LABEL);
      lfoBox->color( fl_rgb_color( 28,28,28 ));
    } // Fl_Box* lfoBox
    { lfoSpeed = new Avtk::Dial(258, 165, 30, 30, "Speed");
      lfoSpeed->box(FL_NO_BOX);
      lfoSpeed->color((Fl_Color)90);
      lfoSpeed->selection_color(FL_INACTIVE_COLOR);
      lfoSpeed->labeltype(FL_NORMAL_LABEL);
      lfoSpeed->labelfont(0);
      lfoSpeed->labelsize(10);
      lfoSpeed->labelcolor(FL_FOREGROUND_COLOR);
      lfoSpeed->callback((Fl_Callback*)cb_lfoSpeed);
      lfoSpeed->align(Fl_Align(FL_ALIGN_BOTTOM));
      lfoSpeed->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* lfoSpeed
    { lfoToW2 = new Avtk::Dial(223, 185, 30, 30, "W2");
      lfoToW2->box(FL_NO_BOX);
      lfoToW2->color((Fl_Color)90);
      lfoToW2->selection_color(FL_INACTIVE_COLOR);
      lfoToW2->labeltype(FL_NORMAL_LABEL);
      lfoToW2->labelfont(0);
      lfoToW2->labelsize(10);
      lfoToW2->labelcolor(FL_FOREGROUND_COLOR);
      lfoToW2->callback((Fl_Callback*)cb_lfoToW2);
      lfoToW2->align(Fl_Align(FL_ALIGN_BOTTOM));
      lfoToW2->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* lfoToW2
    { lfoToW1 = new Avtk::Dial(189, 164, 30, 30, "W 1");
      lfoToW1->box(FL_NO_BOX);
      lfoToW1->color((Fl_Color)90);
      lfoToW1->selection_color(FL_INACTIVE_COLOR);
      lfoToW1->labeltype(FL_NORMAL_LABEL);
      lfoToW1->labelfont(0);
      lfoToW1->labelsize(10);
      lfoToW1->labelcolor(FL_FOREGROUND_COLOR);
      lfoToW1->callback((Fl_Callback*)cb_lfoToW1);
      lfoToW1->align(Fl_Align(FL_ALIGN_BOTTOM));
      lfoToW1->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* lfoToW1
    { lfoAmp = new Avtk::Dial(296, 186, 30, 30, "Amp");
      lfoAmp->box(FL_NO_BOX);
      lfoAmp->color((Fl_Color)90);
      lfoAmp->selection_color(FL_INACTIVE_COLOR);
      lfoAmp->labeltype(FL_NORMAL_LABEL);
      lfoAmp->labelfont(0);
      lfoAmp->labelsize(10);
      lfoAmp->labelcolor(FL_FOREGROUND_COLOR);
      lfoAmp->callback((Fl_Callback*)cb_lfoAmp);
      lfoAmp->align(Fl_Align(FL_ALIGN_BOTTOM));
      lfoAmp->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* lfoAmp
    { filter = new Avtk::Filtergraph(184, 268, 148, 90, "LFO");
      filter->box(FL_UP_BOX);
      filter->color((Fl_Color)179);
      filter->selection_color(FL_INACTIVE_COLOR);
      filter->labeltype(FL_NO_LABEL);
      filter->labelfont(0);
      filter->labelsize(14);
      filter->labelcolor(FL_FOREGROUND_COLOR);
      filter->callback((Fl_Callback*)cb_filter);
      filter->align(Fl_Align(FL_ALIGN_BOTTOM));
      filter->when(FL_WHEN_CHANGED);
    } // Avtk::Filtergraph* filter
    { filterBox = new Fl_Box(184, 364, 148, 70);
      filterBox->box(FL_DOWN_BOX);
      filterBox->labeltype(FL_NO_LABEL);
      filterBox->color( fl_rgb_color( 28,28,28 ));
    } // Fl_Box* filterBox
    { filterCutoff = new Avtk::Dial(200, 375, 50, 45, "Cutoff");
      filterCutoff->box(FL_NO_BOX);
      filterCutoff->color((Fl_Color)90);
      filterCutoff->selection_color(FL_INACTIVE_COLOR);
      filterCutoff->labeltype(FL_NORMAL_LABEL);
      filterCutoff->labelfont(0);
      filterCutoff->labelsize(10);
      filterCutoff->labelcolor(FL_FOREGROUND_COLOR);
      filterCutoff->callback((Fl_Callback*)cb_filterCutoff);
      filterCutoff->align(Fl_Align(FL_ALIGN_BOTTOM));
      filterCutoff->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* filterCutoff
    { filterLfoMod = new Avtk::Dial(264, 377, 50, 40, "Modulation");
      filterLfoMod->box(FL_NO_BOX);
      filterLfoMod->color((Fl_Color)90);
      filterLfoMod->selection_color(FL_INACTIVE_COLOR);
      filterLfoMod->labeltype(FL_NORMAL_LABEL);
      filterLfoMod->labelfont(0);
      filterLfoMod->labelsize(10);
      filterLfoMod->labelcolor(FL_FOREGROUND_COLOR);
      filterLfoMod->callback((Fl_Callback*)cb_filterLfoMod);
      filterLfoMod->align(Fl_Align(FL_ALIGN_BOTTOM));
      filterLfoMod->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* filterLfoMod
    { adsr = new Avtk::ADSR(353, 64, 148, 90, "Adsr");
      adsr->box(FL_UP_BOX);
      adsr->color((Fl_Color)179);
      adsr->selection_color(FL_INACTIVE_COLOR);
      adsr->labeltype(FL_NO_LABEL);
      adsr->labelfont(0);
      adsr->labelsize(14);
      adsr->labelcolor(FL_FOREGROUND_COLOR);
      adsr->callback((Fl_Callback*)cb_adsr);
      adsr->align(Fl_Align(FL_ALIGN_BOTTOM));
      adsr->when(FL_WHEN_CHANGED);
    } // Avtk::ADSR* adsr
    { adsrBox = new Fl_Box(353, 160, 148, 70);
      adsrBox->box(FL_DOWN_BOX);
      adsrBox->labeltype(FL_NO_LABEL);
      adsrBox->color( fl_rgb_color( 28,28,28 ));
    } // Fl_Box* adsrBox
    { sustain = new Avtk::Dial(427, 165, 30, 30, "S");
      sustain->box(FL_NO_BOX);
      sustain->color((Fl_Color)90);
      sustain->selection_color(FL_INACTIVE_COLOR);
      sustain->labeltype(FL_NORMAL_LABEL);
      sustain->labelfont(0);
      sustain->labelsize(11);
      sustain->labelcolor(FL_FOREGROUND_COLOR);
      sustain->callback((Fl_Callback*)cb_sustain);
      sustain->align(Fl_Align(FL_ALIGN_BOTTOM));
      sustain->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* sustain
    { decay = new Avtk::Dial(393, 185, 30, 30, "D");
      decay->box(FL_NO_BOX);
      decay->color((Fl_Color)90);
      decay->selection_color(FL_INACTIVE_COLOR);
      decay->labeltype(FL_NORMAL_LABEL);
      decay->labelfont(0);
      decay->labelsize(11);
      decay->labelcolor(FL_FOREGROUND_COLOR);
      decay->callback((Fl_Callback*)cb_decay);
      decay->align(Fl_Align(FL_ALIGN_BOTTOM));
      decay->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* decay
    { attack = new Avtk::Dial(360, 164, 30, 30, "A");
      attack->box(FL_NO_BOX);
      attack->color((Fl_Color)90);
      attack->selection_color(FL_INACTIVE_COLOR);
      attack->labeltype(FL_NORMAL_LABEL);
      attack->labelfont(0);
      attack->labelsize(11);
      attack->labelcolor(FL_FOREGROUND_COLOR);
      attack->callback((Fl_Callback*)cb_attack);
      attack->align(Fl_Align(FL_ALIGN_BOTTOM));
      attack->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* attack
    { release = new Avtk::Dial(464, 186, 30, 30, "R");
      release->box(FL_NO_BOX);
      release->color((Fl_Color)90);
      release->selection_color(FL_INACTIVE_COLOR);
      release->labeltype(FL_NORMAL_LABEL);
      release->labelfont(0);
      release->labelsize(11);
      release->labelcolor(FL_FOREGROUND_COLOR);
      release->callback((Fl_Callback*)cb_release);
      release->align(Fl_Align(FL_ALIGN_BOTTOM));
      release->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* release
    { volume = new Avtk::Volume(453, 268, 48, 168);
      volume->box(FL_DOWN_BOX);
      volume->color(FL_BACKGROUND_COLOR);
      volume->selection_color(FL_BACKGROUND_COLOR);
      volume->labeltype(FL_NO_LABEL);
      volume->labelfont(0);
      volume->labelsize(14);
      volume->labelcolor(FL_FOREGROUND_COLOR);
      volume->callback((Fl_Callback*)cb_volume);
      volume->align(Fl_Align(FL_ALIGN_CENTER));
      volume->when(FL_WHEN_RELEASE);
    } // Avtk::Volume* volume
    { comp = new Avtk::Compressor(351, 268, 98, 93);
      comp->box(FL_DOWN_BOX);
      comp->color(FL_BACKGROUND_COLOR);
      comp->selection_color(FL_BACKGROUND_COLOR);
      comp->labeltype(FL_NO_LABEL);
      comp->labelfont(0);
      comp->labelsize(14);
      comp->labelcolor(FL_FOREGROUND_COLOR);
      comp->callback((Fl_Callback*)cb_comp);
      comp->align(Fl_Align(FL_ALIGN_CENTER));
      comp->when(FL_WHEN_RELEASE);
      comp->ratio(0.6);
    } // Avtk::Compressor* comp
    { compBox = new Fl_Box(351, 364, 98, 72);
      compBox->box(FL_DOWN_BOX);
      compBox->labeltype(FL_NO_LABEL);
      compBox->color( fl_rgb_color( 28,28,28 ));
    } // Fl_Box* compBox
    { compThres = new Avtk::Dial(404, 369, 30, 30, "Thres");
      compThres->box(FL_NO_BOX);
      compThres->color((Fl_Color)90);
      compThres->selection_color(FL_INACTIVE_COLOR);
      compThres->labeltype(FL_NORMAL_LABEL);
      compThres->labelfont(1);
      compThres->labelsize(11);
      compThres->labelcolor(FL_FOREGROUND_COLOR);
      compThres->callback((Fl_Callback*)cb_compThres);
      compThres->align(Fl_Align(FL_ALIGN_CENTER));
      compThres->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* compThres
    { compAttack = new Avtk::Dial(361, 401, 30, 30, "A");
      compAttack->box(FL_NO_BOX);
      compAttack->color((Fl_Color)90);
      compAttack->selection_color(FL_INACTIVE_COLOR);
      compAttack->labeltype(FL_NORMAL_LABEL);
      compAttack->labelfont(1);
      compAttack->labelsize(12);
      compAttack->labelcolor(FL_FOREGROUND_COLOR);
      compAttack->callback((Fl_Callback*)cb_compAttack);
      compAttack->align(Fl_Align(FL_ALIGN_CENTER));
      compAttack->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* compAttack
    { compMakeup = new Avtk::Dial(361, 369, 30, 30, "Gain");
      compMakeup->box(FL_NO_BOX);
      compMakeup->color((Fl_Color)90);
      compMakeup->selection_color(FL_INACTIVE_COLOR);
      compMakeup->labeltype(FL_NORMAL_LABEL);
      compMakeup->labelfont(1);
      compMakeup->labelsize(11);
      compMakeup->labelcolor(FL_FOREGROUND_COLOR);
      compMakeup->callback((Fl_Callback*)cb_compMakeup);
      compMakeup->align(Fl_Align(FL_ALIGN_CENTER));
      compMakeup->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* compMakeup
    { compRelease = new Avtk::Dial(404, 401, 30, 30, "R");
      compRelease->box(FL_NO_BOX);
      compRelease->color((Fl_Color)90);
      compRelease->selection_color(FL_INACTIVE_COLOR);
      compRelease->labeltype(FL_NORMAL_LABEL);
      compRelease->labelfont(1);
      compRelease->labelsize(12);
      compRelease->labelcolor(FL_FOREGROUND_COLOR);
      compRelease->callback((Fl_Callback*)cb_compRelease);
      compRelease->align(Fl_Align(FL_ALIGN_CENTER));
      compRelease->when(FL_WHEN_CHANGED);
    } // Avtk::Dial* compRelease
    window->end();
  } // Fl_Double_Window* window
}

void SorcerUI::idle() {
  Fl::check();
  Fl::flush();
}

int SorcerUI::getWidth() {
  return window->w();
}

int SorcerUI::getHeight() {
  return window->h();
}

void SorcerUI::writePort(int port, float& value) {
  //cout << "port " << port << " value " << value << endl;
  write_function(controller, port, sizeof(float), 0, &value);
}
